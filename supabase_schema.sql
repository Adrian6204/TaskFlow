
-- Enable UUID extension for unique IDs
create extension if not exists "uuid-ossp";

-- HELPER FUNCTION: Check membership safely (Bypasses RLS to avoid recursion)
create or replace function public.is_space_member(_space_id uuid)
returns boolean language plpgsql security definer as $$
begin
  return exists (
    select 1
    from public.space_members
    where space_id = _space_id
    and user_id = auth.uid()
  );
end;
$$;

-- HELPER FUNCTION: Join a space by code safely
create or replace function public.join_space_by_code(_join_code text)
returns json language plpgsql security definer as $$
declare
  _space_id uuid;
  _space_data record;
begin
  -- 1. Find the space ID
  select id into _space_id from public.spaces where join_code = _join_code;
  
  if _space_id is null then
    raise exception 'Invalid join code';
  end if;

  -- 2. Check if already a member
  if exists (select 1 from public.space_members where space_id = _space_id and user_id = auth.uid()) then
    raise exception 'You are already a member of this space';
  end if;

  -- 3. Insert new member
  insert into public.space_members (space_id, user_id, role)
  values (_space_id, auth.uid(), 'member');

  -- 4. Return space details
  select * from public.spaces where id = _space_id into _space_data;
  return row_to_json(_space_data);
end;
$$;


-- 1. PROFILES
create table if not exists public.profiles (
  id uuid references auth.users not null primary key,
  username text unique,
  avatar_url text,
  updated_at timestamp with time zone
);

alter table public.profiles enable row level security;

drop policy if exists "Public profiles are viewable by everyone." on public.profiles;
create policy "Public profiles are viewable by everyone." on public.profiles
  for select using (true);

drop policy if exists "Users can insert their own profile." on public.profiles;
create policy "Users can insert their own profile." on public.profiles
  for insert with check (auth.uid() = id);

drop policy if exists "Users can update own profile." on public.profiles;
create policy "Users can update own profile." on public.profiles
  for update using (auth.uid() = id);

create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, username, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- 2. SPACES
create table if not exists public.spaces (
  id uuid default uuid_generate_v4() primary key,
  name text not null,
  join_code text unique not null,
  owner_id uuid references public.profiles(id) not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.spaces enable row level security;

drop policy if exists "Enable insert for authenticated users only" on public.spaces;
create policy "Enable insert for authenticated users only" on public.spaces
  for insert to authenticated with check (auth.uid() = owner_id);

drop policy if exists "Enable read for owners and members" on public.spaces;
create policy "Enable read for owners and members" on public.spaces
  for select to authenticated using (
    auth.uid() = owner_id or 
    public.is_space_member(id)
  );


-- 3. SPACE MEMBERS
create table if not exists public.space_members (
  id bigint generated by default as identity primary key,
  space_id uuid references public.spaces(id) on delete cascade not null,
  user_id uuid references public.profiles(id) not null,
  role text default 'member',
  joined_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(space_id, user_id)
);

alter table public.space_members enable row level security;

drop policy if exists "Enable insert for authenticated users" on public.space_members;
create policy "Enable insert for authenticated users" on public.space_members
  for insert to authenticated with check (auth.uid() = user_id);

-- FIXED: This policy now uses the function to avoid recursion
drop policy if exists "Enable read for members of the space" on public.space_members;
create policy "Enable read for members of the space" on public.space_members
  for select to authenticated using (
    public.is_space_member(space_id) or user_id = auth.uid()
  );


-- 4. TASKS
create table if not exists public.tasks (
  id bigint generated by default as identity primary key,
  space_id uuid references public.spaces(id) on delete cascade not null,
  title text not null,
  description text,
  assignee_id uuid references public.profiles(id),
  due_date date,
  status text default 'To Do',
  priority text default 'Medium',
  tags text[] default '{}',
  timer_start_time timestamp with time zone,
  blocked_by_id bigint references public.tasks(id),
  completed_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.tasks enable row level security;

drop policy if exists "Enable access for space members" on public.tasks;
create policy "Enable access for space members" on public.tasks
  for all to authenticated using (
    public.is_space_member(space_id)
  );


-- 5. SUBTASKS
create table if not exists public.subtasks (
  id bigint generated by default as identity primary key,
  task_id bigint references public.tasks(id) on delete cascade not null,
  title text not null,
  is_completed boolean default false
);

alter table public.subtasks enable row level security;

drop policy if exists "Enable access for space members" on public.subtasks;
create policy "Enable access for space members" on public.subtasks
  for all to authenticated using (
    exists (
      select 1 from public.tasks
      where tasks.id = subtasks.task_id
      and public.is_space_member(tasks.space_id)
    )
  );


-- 6. COMMENTS
create table if not exists public.comments (
  id bigint generated by default as identity primary key,
  task_id bigint references public.tasks(id) on delete cascade not null,
  author_id uuid references public.profiles(id) not null,
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.comments enable row level security;

drop policy if exists "Enable access for space members" on public.comments;
create policy "Enable access for space members" on public.comments
  for all to authenticated using (
    exists (
      select 1 from public.tasks
      where tasks.id = comments.task_id
      and public.is_space_member(tasks.space_id)
    )
  );


-- 7. TIME LOGS
create table if not exists public.time_logs (
  id bigint generated by default as identity primary key,
  task_id bigint references public.tasks(id) on delete cascade not null,
  start_time timestamp with time zone not null,
  end_time timestamp with time zone not null,
  duration bigint not null
);

alter table public.time_logs enable row level security;

drop policy if exists "Enable access for space members" on public.time_logs;
create policy "Enable access for space members" on public.time_logs
  for all to authenticated using (
    exists (
      select 1 from public.tasks
      where tasks.id = time_logs.task_id
      and public.is_space_member(tasks.space_id)
    )
  );
